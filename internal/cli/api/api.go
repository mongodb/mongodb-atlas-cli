// Copyright 2024 MongoDB Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package api

import (
	"errors"
	"fmt"
	"io"
	"os"

	"github.com/iancoleman/strcase"
	"github.com/mongodb/mongodb-atlas-cli/atlascli/internal/api"
	"github.com/mongodb/mongodb-atlas-cli/atlascli/internal/log"
	"github.com/spf13/cobra"
	"github.com/spf13/pflag"
)

var (
	ErrFailedToSetUntouchedFlags         = errors.New("failed to set untouched flags")
	ErrServerReturnedAnErrorResponseCode = errors.New("server returned an error response code")
	ErrAPICommandsHasNoVersions          = errors.New("api command has no versions")
)

func Builder() *cobra.Command {
	apiCmd := createRootAPICommand()

	for _, tag := range api.Commands {
		tagCmd := createAPICommandGroupToCobraCommand(tag)

		for _, command := range tag.Commands {
			cobraCommand, err := convertAPIToCobraCommand(command)
			// err should always be nil, errors happening here should be covered by the generate api commands tool
			// if err != nil there is a bug in the converter tool
			if err != nil {
				_, _ = log.Warningf("failed to add command for operationId: %s, err: %s", command.OperationID, err)
				continue
			}

			tagCmd.AddCommand(cobraCommand)
		}

		apiCmd.AddCommand(tagCmd)
	}

	return apiCmd
}

func createRootAPICommand() *cobra.Command {
	return &cobra.Command{
		Use:    "api",
		Hidden: true, // TODO: part of CLOUDP-280743 Polish autogenerated docs
	}
}

func createAPICommandGroupToCobraCommand(group api.Group) *cobra.Command {
	groupName := strcase.ToLowerCamel(group.Name)
	shortDescription, longDescription := splitShortAndLongDescription(group.Description)

	return &cobra.Command{
		Use:   groupName,
		Short: shortDescription,
		Long:  longDescription,
	}
}

func convertAPIToCobraCommand(command api.Command) (*cobra.Command, error) {
	// command properties
	commandName := strcase.ToLowerCamel(command.OperationID)
	shortDescription, longDescription := splitShortAndLongDescription(command.Description)

	// flag values
	file := ""
	version, err := defaultAPIVersion(command)
	if err != nil {
		return nil, err
	}

	cmd := &cobra.Command{
		Use:   commandName,
		Short: shortDescription,
		Long:  longDescription,
		PreRunE: func(cmd *cobra.Command, _ []string) error {
			if err := setUnTouchedFlags(NewProfileFlagValueProviderForDefaultProfile(), cmd); err != nil {
				return errors.Join(ErrFailedToSetUntouchedFlags, err)
			}

			return nil
		},
		RunE: func(cmd *cobra.Command, _ []string) error {
			// Get the request input if needed
			var content io.ReadCloser
			if needsFileFlag(command) {
				content, err = handleInput(cmd)
				if err != nil {
					return err
				}
				defer content.Close()
			}

			// Create a new executor
			executor, err := api.NewDefaultExecutor()
			if err != nil {
				return err
			}

			// Convert the api command + cobra command into a api command request
			commandRequest, err := NewCommandRequestFromCobraCommand(cmd, command, content, version)
			if err != nil {
				return err
			}

			// Execute the api command request
			result, err := executor.ExecuteCommand(cmd.Context(), *commandRequest)
			if err != nil {
				return err
			}

			// TODO: handle output + custom output format, separate ticket: CLOUDP-280747
			defer result.Output.Close()
			_, err = io.Copy(os.Stdout, result.Output)
			if err != nil {
				return err
			}

			if !result.IsSuccess {
				return ErrServerReturnedAnErrorResponseCode
			}

			return nil
		},
	}

	// common flags
	// TODO: proper flag description and constants, CLOUDP-280742
	cmd.Flags().StringVar(&version, "version", version, "api version")
	if needsFileFlag(command) {
		cmd.Flags().StringVar(&file, "file", "", "api request file content")
	}

	if err := addParameters(cmd, command.RequestParameters.URLParameters); err != nil {
		return nil, err
	}

	if err := addParameters(cmd, command.RequestParameters.QueryParameters); err != nil {
		return nil, err
	}

	return cmd, nil
}

func addParameters(cmd *cobra.Command, parameters []api.Parameter) error {
	for _, parameter := range parameters {
		if cmd.Flag(parameter.Name) != nil {
			// this should never happen, the api command generation tool should cover this
			return fmt.Errorf("there is already a parameter with that name, name='%s'", parameter.Name)
		}

		flag := parameterToPFlag(parameter)
		cmd.Flags().AddFlag(flag)

		if parameter.Required {
			_ = cmd.MarkFlagRequired(flag.Name)
		}
	}

	return nil
}

func setUnTouchedFlags(flagValueProvider FlagValueProvider, cmd *cobra.Command) error {
	var visitErr error
	cmd.NonInheritedFlags().VisitAll(func(f *pflag.Flag) {
		// There is no VisitAll which accepts an error
		// because of this we set visitErr when an error occures
		// if visitErr != nil we stop processing other flags
		if visitErr != nil {
			return
		}

		// Only update flags thave have been un-touched by the user
		if !f.Changed {
			value, err := flagValueProvider.ValueForFlag(f.Name)
			if err != nil {
				visitErr = err
			}

			// If we get a value back from the FlagValueProvider:
			// - Set the value
			// - Mark the flag as changed, this is needed to mark required flags as set
			if value != nil {
				if err := f.Value.Set(*value); err != nil {
					visitErr = err
					return
				}

				f.Changed = true
			}
		}
	})

	return visitErr
}

func handleInput(cmd *cobra.Command) (io.ReadCloser, error) {
	// Check if data is being piped to stdin
	info, err := os.Stdin.Stat()
	if err != nil {
		return nil, fmt.Errorf("error checking stdin: %w", err)
	}

	// Check if there's data in stdin (piped input)
	isPiped := (info.Mode() & os.ModeCharDevice) == 0

	if isPiped {
		// Use stdin as the input
		return os.Stdin, nil
	}

	// If not piped, get the file flag
	filePath, err := cmd.Flags().GetString("file")
	if err != nil {
		return nil, fmt.Errorf("error getting file flag: %w", err)
	}

	// Require file flag if not piped
	if filePath == "" {
		return nil, errors.New("--file flag is required when not using piped input")
	}

	// Open the file
	file, err := os.Open(filePath)
	if err != nil {
		return nil, fmt.Errorf("error opening file %s: %w", filePath, err)
	}

	return file, nil
}

func defaultAPIVersion(command api.Command) (string, error) {
	// Command versions are sorted by the generation tool
	nVersions := len(command.Versions)
	if nVersions == 0 {
		return "", ErrAPICommandsHasNoVersions
	}

	lastVersion := command.Versions[nVersions-1]
	return lastVersion.Version, nil
}

func needsFileFlag(apiCommand api.Command) bool {
	for _, version := range apiCommand.Versions {
		if version.RequestContentType != "" {
			return true
		}
	}

	return false
}
