// Copyright 2024 MongoDB Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package api

import (
	"fmt"
	"regexp"
	"strings"

	"github.com/iancoleman/strcase"
	"github.com/mongodb/mongodb-atlas-cli/atlascli/internal/api"
	"github.com/mongodb/mongodb-atlas-cli/atlascli/internal/log"
	"github.com/spf13/cobra"
	"github.com/spf13/pflag"
)

func Builder() *cobra.Command {
	apiCmd := createRootAPICommand()

	for _, tag := range api.Commands {
		tagCmd := createAPICommandGroupToCobraCommand(tag)

		for _, command := range tag.Commands {
			cobraCommand, err := convertAPIToCobraCommand(command)
			// err should always be nil, errors happening here should be covered by the generate api commands tool
			// if err != nil there is a bug in the converter tool
			if err != nil {
				_, _ = log.Warningf("failed to add command for operationId: %s, err: %s", command.OperationID, err)
				continue
			}

			tagCmd.AddCommand(cobraCommand)
		}

		apiCmd.AddCommand(tagCmd)
	}

	return apiCmd
}

func createRootAPICommand() *cobra.Command {
	return &cobra.Command{
		Use: "api",
	}
}

func createAPICommandGroupToCobraCommand(group api.Group) *cobra.Command {
	groupName := strcase.ToLowerCamel(group.Name)
	shortDescription, longDescription := splitShortAndLongDescription(group.Description)

	return &cobra.Command{
		Use:   groupName,
		Short: shortDescription,
		Long:  longDescription,
	}
}

func convertAPIToCobraCommand(command api.Command) (*cobra.Command, error) {
	commandName := strcase.ToLowerCamel(command.OperationID)
	shortDescription, longDescription := splitShortAndLongDescription(command.Description)

	cmd := &cobra.Command{
		Use:    commandName,
		Short:  shortDescription,
		Long:   longDescription,
		Hidden: true, // TODO: part of CLOUDP-280743 Polish autogenerated docs
		RunE: func(cmd *cobra.Command, _ []string) error {
			// TODO: part of CLOUDP-280744 call execution framework
			fmt.Println("Flags:")
			cmd.Flags().Visit(func(f *pflag.Flag) {
				fmt.Printf("%s: %s\n", f.Name, f.Value.String())
			})
			return nil
		},
	}

	if err := addParameters(cmd, command.RequestParameters.URLParameters); err != nil {
		return nil, err
	}

	if err := addParameters(cmd, command.RequestParameters.QueryParameters); err != nil {
		return nil, err
	}

	return cmd, nil
}

func addParameters(cmd *cobra.Command, parameters []api.Parameter) error {
	for _, parameter := range parameters {
		if cmd.Flag(parameter.Name) != nil {
			// this should never happen, the api command generation tool should cover this
			return fmt.Errorf("there is already a parameter with that name, name='%s'", parameter.Name)
		}

		flag := parameterToPFlag(parameter)
		cmd.Flags().AddFlag(flag)

		// TODO: part of CLOUDP-280745 handle values coming from profile
		if parameter.Required {
			_ = cmd.MarkFlagRequired(flag.Name)
		}
	}

	return nil
}

func splitShortAndLongDescription(description string) (string, string) {
	// Split on periods that are followed by a space or end of string
	// This approach allows us to not accidentally split verion numbers like 8.0
	split := regexp.MustCompile(`\.(?:\s+|$)`).Split(description, -1)

	// Short description is the first sentence
	shortDescription := split[0]

	// Add the dot back, if needed
	if shortDescription != "" && !strings.HasSuffix(shortDescription, ".") && !strings.HasSuffix(shortDescription, ". ") {
		shortDescription += "."
	}

	// Long descriptions is everything after the first sentence
	longDescription := ""

	if len(split) > 1 {
		// Remove all empty whitespace around sentences
		// This turns multi-line descriptions into single line
		for i, s := range split[1:] {
			split[i+1] = strings.TrimSpace(s)
		}

		// Add the ". " back
		longDescription = strings.Join(split[1:], ". ")
	}

	// Get rid of the last space after ". "
	longDescription = strings.TrimSpace(longDescription)

	return shortDescription, longDescription
}
